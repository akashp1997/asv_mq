                                Documentation of Producer 


    A producer is a user application that sends messages.
    A queue is a buffer that stores messages.
    A consumer is a user application that receives messages.


PUBLISHER:The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. Actually, quite often the producer doesn't even know if a message will be delivered to any queue at all.

Instead, the producer can only send messages to an exchange. An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives. Should it be appended to a particular queue? Should it be appended to many queues? Or should it get discarded. The rules for that are defined by the exchange type.
 					BASIC PRODUCER PROGRAM


#!/usr/bin/env python
import pika
import sys

connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
channel = connection.channel()

channel.exchange_declare(exchange='logs',
                         exchange_type='topic')

message = ' '.join(sys.argv[1:]) or "info: Hello World!"
channel.basic_publish(exchange='logs',
                      routing_key='',
                      body=message)
print(" [x] Sent %r" % message)
connection.close()

					PRODUCER PROGRAM CLASS

class Publisher(Channel):
	def __init__(self, topic_name, object_type=str, hostname="localhost", port=5672):
        self._object_type = object_type
        self._topic = topic_name
        Channel.__init__(self, exchange_name=DEFAULT_EXCHANGE_NAME, exchange_type="topic", hostname=hostname, port=port)

    @property
    def type(self):
        """Returns the type of object to be strictly followed by the Publisher to send"""
        return self._object_type

    @property
    def topic(self):
        """Returns the topic name specified during class creation"""
        return self._topic

    def __str__(self):
        """Returns the debug information of the publisher"""
        return "Publisher on topic %s on %s:%d, of type %s" % (self.topic, self.hostname, self.port, str(self.type))

    def close(self):
        """Destroys the object and deletes the exchange"""
        try:
            self._channel.exchange_delete(self.exchange_name, if_unused=True)
        except:
            pass
        Channel.close(self)

    def publish(self, message):
        """Method for publishing the message to the MQ Broker"""
        if(type(message)!=self.type):
            raise ValueError("Please ensure that the message passed to this method is of the same type as defined during the Publisher declaration")
        if(type(message)!=str):
            try:
                message = message.SerializeToString()
            except:
                raise ValueError("Are you sure that the message is Protocol Buffer message/string?")
        success = self._channel.basic_publish(exchange=self.exchange_name,routing_key=self.topic, body=message)
        if(not success):
            raise pika.exceptions.ChannelError("Cannot deliver message to exchange")

					HOW TO USE THIS CLASS
	Make a object of class publisher.Then initiate.
	To use for publisher in Topic topology. Use exchange name as 'asvmq'
    	To publish, first initialize the class in the following manner:
    	obj = Publisher(<topic_name>,[<object_type>], [<hostname>], [<port>])
    	and then publish the message of type as follows:
    	obj.publish(object), where object=object_type defined
	The arguments in sqare brackets are not mandotory.
				BASIC PROGRAM TO USE THIS CLASS

#!/usr/bin/env python
import asvprotobuf.sensor_pb2
import asvmq
import time
import math
import pika

def create_message():
    msg = asvprotobuf.sensor_pb2.Imu()
    t = time.time()
    msg.header.stamp.seconds = int(t)
    msg.header.stamp.nanos = int((t%1)*10**9)
    msg.header.frame_id="imu"
    msg.orientation.roll = 0
    msg.orientation.pitch = 0
    msg.orientation.yaw = math.pi/2
    msg.angular_velocity.x = 0
    msg.angular_velocity.y = 0
    msg.angular_velocity.z = math.pi/20
    msg.acceleration.x = 0
    msg.acceleration.y = 0
    msg.acceleration.z = 9.81
    msg.acceleration_variance.x = 0
    msg.acceleration_variance.y = 0
    msg.acceleration_variance.z = 0.01
    msg.temperature = 36
    return msg

pub = asvmq.Publisher("hello", asvprotobuf.sensor_pb2.Imu)
while True:
    pub.publish(create_message())










